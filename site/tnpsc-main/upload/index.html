<!DOCTYPE html>
<html lang="ta">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Question Converter</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f2f5; color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; }
        .container { background-color: white; padding: 40px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); text-align: center; max-width: 600px; width: 100%; }
        h1 { color: #007bff; }
        p { color: #666; }
        input[type="file"] { border: 2px dashed #007bff; padding: 20px; border-radius: 5px; cursor: pointer; display: block; margin: 20px auto; }
        #status { margin-top: 20px; font-weight: bold; color: #28a745; min-height: 25px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>ஸ்மார்ட் கேள்வித்தாள் மாற்றி</h1>
        <p>உங்கள் கேள்வித்தாள் PDF அல்லது Image கோப்பை இங்கே தேர்வு செய்யவும்.</p>
        <input type="file" id="fileInput" accept=".pdf, image/*">
        <div id="status"></div>
    </div>

    <!-- JavaScript Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

    <script>
        const fileInput = document.getElementById('fileInput');
        const statusDiv = document.getElementById('status');

        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            statusDiv.textContent = 'கோப்பு செயலாக்கப்படுகிறது...';
            fileInput.disabled = true;

            try {
                let text = '';
                if (file.type === 'application/pdf') {
                    statusDiv.textContent = 'PDF கோப்பிலிருந்து உரையை எடுக்கிறது...';
                    text = await extractTextFromPdf(file);
                } else if (file.type.startsWith('image/')) {
                    statusDiv.textContent = 'Image-லிருந்து உரையை எடுக்கிறது (OCR)... இது சிறிது நேரம் எடுக்கும்.';
                    text = await extractTextFromImage(file);
                }
                
                statusDiv.textContent = 'உரையை கேள்விகளாகப் பிரிக்கிறது...';
                const questions = parseQuestions(text);

                if (questions.length === 0) {
                    statusDiv.textContent = 'கேள்விகள் எதுவும் கண்டுபிடிக்கப்படவில்லை. கோப்பின் வடிவத்தை சரிபார்க்கவும்.';
                    console.log("Extracted Text For Debugging:\n", text);
                    return;
                }

                statusDiv.textContent = `மொத்தம் ${questions.length} கேள்விகள் கண்டறியப்பட்டன. Excel கோப்பை உருவாக்குகிறது...`;
                generateExcel(questions, file.name.split('.')[0]);
                
                statusDiv.textContent = 'Excel கோப்பு வெற்றிகரமாக பதிவிறக்கம் செய்யப்பட்டது!';

            } catch (error) {
                console.error('Error:', error);
                statusDiv.textContent = 'ஒரு பிழை ஏற்பட்டது. Console-ஐப் பார்க்கவும்.';
            } finally {
                fileInput.disabled = false;
                fileInput.value = '';
            }
        });
        
        async function extractTextFromPdf(file) { /* ... No changes here ... */ 
            const fileReader = new FileReader();
            return new Promise((resolve, reject) => {
                fileReader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;
                    const pdf = await pdfjsLib.getDocument(typedarray).promise;
                    let fullText = '';
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        let lastY = -1;
                        textContent.items.forEach(item => {
                            if (lastY !== -1 && Math.abs(item.transform[5] - lastY) > 5) fullText += '\n';
                            fullText += item.str + ' ';
                            lastY = item.transform[5];
                        });
                        fullText += '\n\n';
                    }
                    resolve(fullText);
                };
                fileReader.onerror = reject;
                fileReader.readAsArrayBuffer(file);
            });
        }
        
        async function extractTextFromImage(file) { /* ... No changes here ... */
            const { data: { text } } = await Tesseract.recognize(
                file, 'tam+eng',
                { logger: m => { statusDiv.textContent = `${m.status} (${(m.progress * 100).toFixed(0)}%)...`; } }
            );
            return text;
        }

        function parseQuestions(text) {
            // ******** படி 1: தேவையற்ற வரிகளை நீக்க ஒரு புதிய ப்ரீ-ப்ராசசிங் படி ********
            let preCleanedText = text
                // 'Turn over', 'P.T.O' போன்ற வரிகளை நீக்குதல் (case-insensitive)
                .replace(/^.*(turn over|p\.t\.o\.?).*$/gim, '')
                // 'XXXX/2021' போன்ற கோடுகளைக் கொண்ட வரிகளை நீக்குதல்
                .replace(/^.*[a-z0-9]+\/\d{4}.*$/gim, '')
                // பக்க எண்கள் மட்டும் உள்ள வரிகளை நீக்குதல்
                .replace(/^\s*\d+\s*$/gm, '')
                // பல வெற்று வரிகளை ஒன்றாகச் சுருக்குதல்
                .replace(/\n{3,}/g, '\n\n');


            const questions = [];
            // ப்ரீ-ப்ராசஸ் செய்யப்பட்ட உரையை இப்போது பயன்படுத்துகிறோம்
            const cleanedText = preCleanedText.replace(/(\r\n|\r)/g, '\n').replace(/ +/g, ' ');
            const questionBlocks = cleanedText.split(/(?=\n*\s*\d+[\.\)])/);

            for (const block of questionBlocks) {
                const trimmedBlock = block.trim();
                if (trimmedBlock.length < 10) continue;

                const questionRegex = /^(\d+[\.\)])\s*([\s\S]*?)(?=\s*(?:\(A\)|A[\.\)])\s*)/i;
                const questionMatch = trimmedBlock.match(questionRegex);
                
                if (!questionMatch) continue;

                const questionNumber = questionMatch[1].trim();
                const questionText = questionMatch[2].replace(/\n/g, ' ').trim();
                const optionsString = trimmedBlock.substring(questionMatch[0].length);

                const optionParts = optionsString.split(/(?=\s*(?:\([B-Z]\)|[B-Z][\.\)])\s*)/i);
                
                const result = {
                    'கேள்வி எண்': questionNumber,
                    'கேள்வி': questionText
                };

                const cleanOption = (str) => {
                    if (!str) return '';
                    return str.replace(/^\s*(?:\([A-Z]\)|[A-Z][\.\)])\s*/i, '').replace(/\n/g, ' ').trim();
                };
                
                let validOptionIndex = 0;
                optionParts.forEach((part) => {
                    const cleanedOptionText = cleanOption(part);
                    if (cleanedOptionText && /[a-zA-Z0-9\u0B80-\u0BFF]/.test(cleanedOptionText)) {
                        const optionLetter = String.fromCharCode(65 + validOptionIndex);
                        const columnName = `விருப்பம் ${optionLetter}`;
                        result[columnName] = cleanedOptionText;
                        validOptionIndex++;
                    }
                });
                
                if (validOptionIndex > 0) {
                    questions.push(result);
                }
            }
            return questions;
        }
        
        function generateExcel(data, fileName) { /* ... No changes here ... */
            const worksheet = XLSX.utils.json_to_sheet(data);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Questions');

            if (data.length > 0) {
                const colWidths = Object.keys(data[0]).map(key => ({
                    wch: Math.max(...data.map(row => row[key] ? row[key].length : 0), key.length) + 2
                }));
                worksheet['!cols'] = colWidths;
            }

            XLSX.writeFile(workbook, `${fileName}_questions.xlsx`);
        }
    </script>
</body>
</html>